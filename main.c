#include "gba.h"
#include "logic.h"
#include "graphics.h"
// TA-TODO: Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
//#include "images/garbage.h"
#include "images/grass.h"
#include "images/snake1.h"
#include "images/gameOver.h"
#include "images/mushroom.h"
#include "images/skin.h"
#include "images/sand.h"
#include "images/garbage.h"

#include <stdio.h>
#include <stdlib.h>

// AppState enum definition

#define REG_DISPCTL *(unsigned short *)0x4000000
#define MODE3 3
#define BG2_ENABLE (1<<10)
#define MAX_LENGTH 30
u32 previousButtons;
u32 currentButtons;
void clear(void);
void slide(int direction, AppState * currentAppState, AppState * nextAppState);
void getDirection(AppState * currentAppState, AppState * nextAppState);
void drawSnake(AppState * currentAppState);
void drawFood(AppState * nextAppState);
void eat(AppState * currentAppState, AppState * nextAppState);
void eraseSnake(AppState * currentAppState);
void isDead(AppState * currentAppState, AppState * nextAppState);
void delayImage(int number);

typedef enum {
    // TA-TODO: Add any additional states you need for your app.
    START,
    START_NODRAW,
    APP_INIT,
    APP,
    APP_EXIT,
    APP_EXIT_NODRAW,
} GBAState;

void delayImage(int number) {
	volatile int x = 0;
	for (int i = 0; i < number * 5000; i++) {
		x++;
	}
}


void clear(void) {
	drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);
}

void eat(AppState * currentAppState, AppState * nextAppState) {
	if (currentAppState->pos[0][0] == currentAppState->food[0] && currentAppState->pos[0][1] == currentAppState->food[1]) {
		nextAppState->length++;
		nextAppState->eaten = 1;
		drawImageDMA(currentAppState->food[0] * 10, currentAppState->food[1] * 10, 10, 10, sand);
		nextAppState->food[0] = randint(0, 16);
		nextAppState->food[1] = randint(0, 24);
		drawString(10, 0, "YEAH! YOU GOT FOOD", BLACK);
		drawFood(nextAppState);
	}
}

void slide(int direction, AppState * currentAppState, AppState * nextAppState) {
	for (int i = currentAppState->length - 1; i > 0; i--) {
		nextAppState->pos[i][0] = currentAppState->pos[i - 1][0];
		nextAppState->pos[i][1] = currentAppState->pos[i - 1][1];
	}

	
	if (direction == 1) {
		nextAppState->pos[0][0] -= 1;
	}
	if (direction == 2) {
		nextAppState->pos[0][0] += 1;
	}
	if (direction == 3) {
		nextAppState->pos[0][1] -= 1;
	}
	if (direction == 4) {
		nextAppState->pos[0][1] += 1;
	}
	if (nextAppState->pos[0][1] > 23) {
		nextAppState->gameOver = 1;
	}
	if (nextAppState->pos[0][1] < 0) {
		nextAppState->gameOver = 1;
	}
	if (nextAppState->pos[0][0] > 16) {
		nextAppState->gameOver = 1;
	}
	if (nextAppState->pos[0][0] < 0) {
		nextAppState->gameOver = 1;
	}

	if (currentAppState->eaten == 1) {
		nextAppState->eaten = 0;
	}
}

void getDirection(AppState * currentAppState, AppState * nextAppState) {
	if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) && currentAppState->currDir != 2) {
		nextAppState->currDir = 1;
		slide(1, currentAppState, nextAppState);
	}
	else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) && currentAppState->currDir != 1) {
		nextAppState->currDir = 2;
		slide(2, currentAppState, nextAppState);
	}
	else if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) && currentAppState->currDir != 4) {
		nextAppState->currDir = 3;
		slide(3, currentAppState, nextAppState);
	}
	else if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) && currentAppState->currDir != 3) {
		nextAppState->currDir = 4;
		slide(4, currentAppState, nextAppState);
	}
}


void drawSnake(AppState * currentAppState) {
	for (int i = 0; i < currentAppState->length; i++) {
		drawImageDMA((currentAppState->pos[i][0] * 10), (currentAppState->pos[i][1] * 10), 10, 10, skin);
	}
}

void eraseSnake(AppState * currentAppState) {
	for (int i = 0; i < currentAppState->length; i++) {
		drawImageDMA((currentAppState->pos[i][0] * 10), (currentAppState->pos[i][1] * 10), 10, 10, sand);
	}
}



void drawFood(AppState * currentAppState) {
	drawImageDMA(currentAppState->food[0] * 10, currentAppState->food[1] * 10, 10, 10, mushroom);
}

void isDead(AppState * currentAppState, AppState * nextAppState) {
	if (currentAppState->length != 1) {
		for (int i = 1; i < currentAppState->length; i++) {
			if (currentAppState->pos[0][0] == currentAppState->pos[i][0] && currentAppState->pos[0][1] == currentAppState->pos[i][1]) {
				eraseSnake(currentAppState);
				currentAppState->lives--;
				nextAppState->lives = currentAppState->lives;
				currentAppState->length = i;
				nextAppState->length = currentAppState->length;
				if (currentAppState->lives <= 0) {
					currentAppState->gameOver = 1;
					nextAppState->gameOver = 1;
				}
				drawImageDMA(0, 0, 240, 10, sand);
				for (int j = i; j < currentAppState->length; j++) {
					drawImageDMA(currentAppState->pos[j][0], currentAppState->pos[i][1], 10, 10, sand);
				}
			}
		}
	}
}

int main(void) {
    // TA-TODO: Manipulate REG_DISPCNT here to set Mode 3.
	REG_DISPCTL = MODE3 | BG2_ENABLE;
	int row = 160;
	int col = 240;
	setPixel(row, col, 0x7fff);
//	int foodX = (rand() % 240);
//	int foodY = (rand() % 160);
//	food[0] = foodX;
//	food[1] = foodY;



    GBAState state = START;

    // We store the "previous" and "current" states.
    AppState currentAppState, nextAppState;
	int drawed = 0;




    // We store the current and previous values of the button input.

    while(1) {
        // Load the current state of the buttons
		currentButtons = BUTTONS;
		previousButtons = BUTTONS;

        // TA-TODO: Manipulate the state machine below as needed.
		switch (state) {
		case START:
			waitForVBlank();
			// TA-TODO: Draw the start state here.
			drawFullScreenImageDMA(snake1);
			drawString(80, 130, "L O A D I N G", BLACK);
			delayImage(50);
			drawFullScreenImageDMA(snake1);
			delayImage(50);
			drawString(80, 130, "L O A D I N G", BLACK);
			delayImage(50);
			drawFullScreenImageDMA(snake1);
			delayImage(50);
			drawString(80, 130, "L O A D I N G", BLACK);
			delayImage(50);
			drawFullScreenImageDMA(snake1);
		    state = START_NODRAW;
	
            break;
        case START_NODRAW:
            // TA-TODO: Check for a button press here to start the app.
            // Start the app by switching the state to APP_INIT.
			waitForVBlank();
			if (drawed == 0) {
				drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);
				drawString(75, 20, "ENTER TO START", WHITE);
				drawString(0, 35, "========================================", WHITE);
				delayImage(50);
				drawString(55, 55, "! TRY EAT MUSHROOMS", WHITE);
				delayImage(50);
				drawString(15, 70, "! AVOID STEPPING ON YOUR OWN BODY", WHITE);
				delayImage(50);
				drawString(85, 85, "! 3 LIVES", WHITE);
				delayImage(50);
				drawString(55, 100, "! NEVER TOUCH WALL", WHITE);
				delayImage(50);
				drawString(0, 125, "========================================", WHITE);
				drawString(68, 140, "BACKSPACE TO QUIT", WHITE);
				drawed = 1;
			}
			if (KEY_DOWN(BUTTON_START, BUTTONS)) {
				state = APP_INIT;
			}
            break;

        case APP_INIT:
			drawFullScreenImageDMA(sand);
			currentAppState.currDir = 0;
			currentAppState.food[0] = 10;
			currentAppState.food[1] = 5;
			currentAppState.pos[0][0] = 0;
			currentAppState.pos[0][1] = 0;
			currentAppState.length = 1;
			currentAppState.lives = 3;
			currentAppState.gameOver = 0;
			char buffer[50];
			sprintf(buffer, "lives: %d    length: %d", currentAppState.lives, currentAppState.length);
			drawString(50, 0, buffer, BLACK);
            // Initialize the app. Switch to the APP state.
            initializeAppState(&currentAppState);

            // Draw the initial state of the app
            fullDrawAppState(&currentAppState);

            state = APP;
            break;
        case APP:
            // Process the app for one frame, store the next state
            //nextAppState = processAppState(&currentAppState, previousButtons, currentButtons);
			//delayImage(1);
			//drawFullScreenImageDMA(grass);
			if (KEY_JUST_PRESSED(BUTTON_SELECT, BUTTONS, BUTTONS)) {
				clear();
				state = START_NODRAW;
				drawed = 0;
			}
			nextAppState = currentAppState;
			drawFood(&currentAppState);
			getDirection(&currentAppState, &nextAppState);
			eat(&currentAppState, &nextAppState);
			isDead(&currentAppState, &nextAppState);
			drawImageDMA(0, 0, 240, 10, sand);
			sprintf(buffer, "lives: %d    length: %d", currentAppState.lives, currentAppState.length);
			drawString(50, 0, buffer, BLACK);
			eraseSnake(&currentAppState);
			drawSnake(&nextAppState);


            // Wait for VBlank before we do any drawing.
            waitForVBlank();

            // Undraw the previous state
            undrawAppState(&currentAppState);

            // Draw the current state
            drawAppState(&nextAppState);

            // Now set the current state as the next state for the next iter.
            currentAppState = nextAppState;
			previousButtons = BUTTONS;
			currentButtons = BUTTONS;

            // Check if the app is exiting. If it is, then go to the exit state.
            if (currentAppState.gameOver) state = APP_EXIT;

            break;
        case APP_EXIT:
            // Wait for VBlank
            waitForVBlank();

            // TA-TODO: Draw the exit / gameover screen
			drawImageDMA(0, 0, WIDTH, HEIGHT, gameOver);
            state = APP_EXIT_NODRAW;
            break;
        case APP_EXIT_NODRAW:
            // TA-TODO: Check for a button press here to go back to the start screen
			drawString(45, 25, "PRESS BACKSPACE TO RESTART", WHITE);
			if (KEY_JUST_PRESSED(BUTTON_SELECT, BUTTONS, BUTTONS)) {
				clear();
				state = START_NODRAW;
				drawed = 0;
			}
            break;
        }

        // Store the current state of the buttons
        previousButtons = currentButtons;
    }

    return 0;
}

